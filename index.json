[{"categories":["Writeups"],"content":"Writeup for Q4N1 challenge.","date":"2024-08-13","objectID":"/circuits/","tags":["Misc","MCSC","Q4N1"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Writeup for Quantum challenge from MCSC 2024. from qiskit import QuantumCircuit, execute, Aer # Create a quantum circuit with 7 qubits and 7 classical bits circuit = QuantumCircuit(7, 7) # Apply the gates from your OPENQASM code circuit.cz(2, 4) circuit.z(2) circuit.cy(2, 4) # ... (add the remaining gates) # Measure all qubits circuit.measure(range(7), range(7)) # Choose a backend (simulator or real quantum computer) simulator = Aer.get_backend('qasm_simulator') # Execute the circuit and get the counts job = execute(circuit, backend=simulator, shots=1024) # Increase shots for better statistics counts = job.result().get_counts() # Print the measurement results print(counts) ","date":"2024-08-13","objectID":"/circuits/:0:0","tags":["Misc","MCSC","Q4N1"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Explanation You create a quantum circuit with 7 qubits and 7 classical bits, where quantum operations are performed on the qubits, and the classical bits store the measurement results. Several quantum gates are applied, including a controlled-Z gate (cz) where qubit 2 controls qubit 4, a Z gate that flips the phase of qubit 2, and a controlled-Y gate (cy) with qubit 2 as the control and qubit 4 as the target. After adding the necessary gates, all 7 qubits are measured, with the results stored in the corresponding classical bits. The circuit is then simulated using the qasm_simulator backend, which mimics a real quantum computer. The circuit is executed 1024 times to gather statistical outcomes, and the measurement results are retrieved and displayed as a dictionary, showing the frequency of each possible outcome in binary form. ","date":"2024-08-13","objectID":"/circuits/:1:0","tags":["Misc","MCSC","Q4N1"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Writeup for zipbomb challenge.","date":"2024-08-13","objectID":"/zipbomb/","tags":["Misc","MCSC","Zipbomb"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":["Writeups"],"content":"Writeup for Zipbomb challenge from MCSC 2024. import base64 import string import gzip import binascii import io import py7zr import os import re brail=\"‚†¥‚†Ç‚†Ü‚†í‚†≤‚†¢‚†ñ‚†∂‚†¶‚†î‚†Å‚†É‚†â‚†ô‚†ë‚†ã‚†õ‚†ì‚†ä‚†ö‚†Ö‚†á‚†ç‚†ù‚†ï‚†è‚†ü‚†ó‚†é‚†û‚†•‚†ß‚†∫‚†≠‚†Ω‚†µ‚†Å‚†É‚†â‚†ô‚†ë‚†ã‚†õ‚†ì‚†ä‚†ö‚†Ö‚†á‚†ç‚†ù‚†ï‚†è‚†ü‚†ó‚†é‚†û‚†•‚†ß‚†∫‚†≠‚†Ω‚†µ‚†Æ‚†ê‚†º‚†´‚†©‚†Ø‚†Ñ‚†∑‚†æ‚†°‚†¨‚††‚†§‚†®‚†å‚†±‚†∞‚†£‚†ø‚†ú‚†π‚†à‚†™‚†≥‚†ª‚†ò‚†∏\" strings = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%\u0026'()*+,-./:;\u003c=\u003e?@[\\\\]^_\" def contains_braille(text): brail = \"‚†¥‚†Ç‚†Ü‚†í‚†≤‚†¢‚†ñ‚†∂‚†¶‚†î‚†Å‚†É‚†â‚†ô‚†ë‚†ã‚†õ‚†ì‚†ä‚†ö‚†Ö‚†á‚†ç‚†ù‚†ï‚†è‚†ü‚†ó‚†é‚†û‚†•‚†ß‚†∫‚†≠‚†Ω‚†µ‚†Å‚†É‚†â‚†ô‚†ë‚†ã‚†õ‚†ì‚†ä‚†ö‚†Ö‚†á‚†ç‚†ù‚†ï‚†è‚†ü‚†ó‚†é‚†û‚†•‚†ß‚†∫‚†≠‚†Ω‚†µ‚†Æ‚†ê‚†º‚†´‚†©‚†Ø‚†Ñ‚†∑‚†æ‚†°‚†¨‚††‚†§‚†®‚†å‚†±‚†∞‚†£‚†ø‚†ú‚†π‚†à‚†™‚†≥‚†ª‚†ò‚†∏\" for char in text: if char in brail: return True return False def contains_hexadecimal(text): return all(c in string.hexdigits for c in text) def contains_non_printables(text): # Iterate over each character in the text for char in text: # Check if the character is non-printable or matches specific value like '√ø' if not char.isprintable(): return True # If no non-printable characters are found, return False return False def convertbraille(text): result = \"\" for char in text: result += strings[brail.index(char)] return result def hex_to_string(hex_str): try: # Convert hexadecimal string to bytes hex_bytes = bytes.fromhex(hex_str) # Convert bytes to string return hex_bytes.decode('ascii') except Exception as e: print(\"Error:\", e) return None def gunzip_bytes_obj(text): text = text.encode('latin1') text = gzip.GzipFile(fileobj=io.BytesIO(text), mode='rb') text = text.read().decode('utf-8') return text def is_base32(s): # Define the Base32 alphabet s=s.upper() print(s) base32_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567' # Check if all characters in the string are part of the Base32 alphabet for char in s: if char not in base32_alphabet: if char==\"=\": return True return False return True def extract_7z_with_password(archive_path, output_dir, password): try: # Open the 7z archive with the provided password with py7zr.SevenZipFile(archive_path, mode='r', password=password) as z: # Extract all files to the specified output directory z.extractall(path=output_dir) print(f\"Extraction of {archive_path} successful!\") os.chdir(output_dir) except Exception as e: print(f\"Extraction of {archive_path} failed:\", e) def extract_from_directory(directory, output_dir, password): # Iterate through files in the directory for filename in os.listdir(directory): if filename.endswith(\".7z\"): # Check if the file ends with \".7z\" # Construct the full path to the 7z archive archive_path = os.path.join(directory, filename) # Attempt to extract the 7z archive extract_7z_with_password(archive_path, output_dir, password) #while True: i=1 while True: with open('crack_me', 'r',encoding='utf-8') as file: # Read the entire contents of the file text = file.read() with open('backup_me', 'x',encoding='utf-8') as file: file.write(text) # Now 'text' contains the contents of the file while (type(text) == str): if contains_braille(text): text=convertbraille(text) elif contains_non_printables(text): text=gunzip_bytes_obj(text) elif contains_hexadecimal(text): text = ''.join([chr(int(text[i:i+2], 16)) for i in range(0, len(text), 2)]) else : text=text.upper() text = base64.b32decode(text).decode('utf-8') print(text,end=\"\\n\\n\") if len(text) \u003c= len(\"SKOWJUHYISBWNOQMZUOQOZXZPOTVAW\") : if contains_braille(text)==False: break text=text.upper() extract_from_directory('.', './'+str(i), text) i+=1 ","date":"2024-08-13","objectID":"/zipbomb/:0:0","tags":["Misc","MCSC","Zipbomb"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":["Writeups"],"content":"Explanation It‚Äôs a simple automation of the decoding steps The logic goes : detect if it‚Äôs braille hex or gunzipped, decode it, cd to the new directory,rinse and repeat. ","date":"2024-08-13","objectID":"/zipbomb/:1:0","tags":["Misc","MCSC","Zipbomb"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":null,"content":"About Me","date":"0001-01-01","objectID":"/aboutme/","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Background Information I like computers ü§ì‚ùó ","date":"0001-01-01","objectID":"/aboutme/:0:0","tags":null,"title":"About Me","uri":"/aboutme/"}]